%=======================================================================
% riscv-privileged.tex
%-----------------------------------------------------------------------

\documentclass[twoside,11pt]{book}

\input{preamble}

% All registers are named here. That way when we rename one we'll get errors if
% there are still references to the old name.

\usepackage{xspace}
\newcommand{\defregname}[2]{\providecommand{#1}{{\tt #2}\xspace}}
\newcommand{\deffieldname}[2]{\providecommand{#1}{{$|#2|$}\xspace}}
\deffieldname{\Fmprv}{mprv}
\defregname{\Rmstatus}{mstatus}

\defregname{\Azero}{a0}
\defregname{\Aone}{a1}

\defregname{\Rzero}{zero}
\defregname{\Szero}{s0}
\defregname{\Sone}{s1}

\defregname{\Tzero}{t0}

\defregname{\Xzero}{x0}
\defregname{\Xone}{x1}
\defregname{\Xeight}{x8}
\defregname{\Xnine}{x9}
\defregname{\Xten}{x10}
\defregname{\Xeleven}{x11}
\defregname{\Xthirtyone}{x31}
\defregname{\Fone}{f1}
\defregname{\Rpc}{pc}
\defregname{\Rmhartid}{mhartid}
\defregname{\Rmepc}{mepc}

\input{hwbp_registers.tex.inc}
\input{core_registers.tex.inc}
\input{jtag_registers.tex.inc}
\input{dm1_registers.tex.inc}
\input{dm2_registers.tex.inc}
\input{trace_registers.tex.inc}
\input{sample_registers.tex.inc}
\input{abstract_commands.tex.inc}

\input{vc.tex}

\newcommand{\versionnum}{0.13}
\newcommand{\shortdate}{jan24}
\newcommand{\longdate}{January 24, 2017}


\begin{document}

\title{RISC-V External Debug Support\\
Version \versionnum\\
\GITHash
}
\author{Tim Newsome \textless tim@sifive.com\textgreater}
\date{\GITAuthorDate}
\maketitle

\markboth{RISC-V External Debug Support Version \versionnum}
{RISC-V External Debug Support Version \versionnum}
\thispagestyle{empty}

\frontmatter

\input{preface.tex}

\tableofcontents
\listoffigures
\listoftables

\mainmatter

\newpage

\input{introduction}
\input{overview}
\input{debug_module}
\input{core_debug}
\input{trigger}
\input{dtm}

\newpage
\appendix

\include{jtagdtm}

\chapter{Hardware Implementations}

Below are two possible implementations. A designer could choose one, mix and
match, or come up with their own design.

\section{Direct}

Halting happens by inhibiting instruction fetching in Debug Mode.

Muxes on the register file(s) allow for implementing those abstract commands.
(TODO: Should we spec a suggested way of communicating between DM and hart, so
that a reusable DM can be implemented?)

To execute a program buffer, force \Rpc to the start of it, and re-enable
instruction fetching (while staying in Debug Mode) until {\tt ebreak} is
encountered.

\Rdpc is not physically a CSR. Instead, accessing it directly access \Rpc.

\section{Plain Exception}

In this implementation, Debug Mode acts more like a real exception, jumping to a
memory region that is serviced by the DM. When taking this exception, \Rpc is
saved to \Rdpc. To allow the DM to individually control one out of several
halted harts, each hart jumps to a hard-coded unique address.

\Rdatazero etc. are mapped into regular memory at address 0x400. The important
property of that address is that it's reachable relative to \Rzero. The exact
address is an implementation detail that a debugger must not rely on.

When first halting, the code there looks like this:
\begin{minted}{gas}
dm_park_hart_0:
        nop
        j       dm_park_hart_0

dm_exception_hart_0:
        j       dm_park_hart_0
\end{minted}

The DM assumes that every instruction fetched from it is executed.

To implement the abstract 32-bit GPR access instructions, the {\tt nop} is
changed (for a single fetch) to {\tt lw <gpr>, 0x400(zero)} or {\tt sw
0x400(zero), <gpr>}. 64- and 128-bit accesses use {\tt ld}/{\tt sd} and {\tt
lq}/{\tt sq} respectively.

To execute the Program Buffer, the {\tt nop} is changed to {\tt j
dm\_program\_buffer}. When {\tt ebreak} is executed (indicating the end of the
Program Buffer code) the hart jumps back to its park loop. If an exception is
encountered, the hart jumps to its debug exception address, which in turn
contains a jump back to its park loop. The DM infers from the fetch at the park
address that there was an exception, and sets \Fcmderr appropriately.

To resume execution, the {\tt nop} is changed to {\tt dret}.  When {\tt dret}
is executed, \Rpc is restored from \Rdpc and normal execution resumes at the
privilege set by \Fprv.

\chapter{Debugger Implementation}

This section details how an external debugger might use the described debug
interface to perform some common operations on RISC-V cores using the JTAG DTM.
All these examples assume a 32-bit core but it should be easy to adapt the
examples to 64- or 128-bit cores.

To keep the examples readable, they all assume that everything succeeds, and
that they complete faster than the debugger can perform the next access. This
will be the case in a typical JTAG setup. However, the debugger must always
check the sticky error status bits after performing a sequence of actions. If
it sees any that are set, then it should attempt the same actions again,
possibly while adding in some delay, or explicit checks for status bits.

\section{Debug Bus Access} \label{dbusaccess}

To read an arbitrary Debug Bus register, select \Rdmi, and scan in a value
with \Fop set to 1, and \Faddress set to the desired register address. In
Update-DR the operation will start, and in Capture-DR its results will be
captured into \Fdata.  If the operation didn't complete in time, \Fop will be 3
and the value in \Fdata must be ignored. The error condition must be cleared by
writing \Fdmireset in \Rdtmcs, and then the operation must be tried
again. This time the debugger should allow for more time between Capture-DR and
Update-DR.

To write an arbitrary Debug Bus register, select \Rdmi, and scan in a value
with \Fop set to 2, and \Faddress and \Fdata set to the desired register
address and data respectively. From then on everything happens exactly as with
a read, except that a write is also performed right after the read. The
operation isn't considered complete until the write has happened.

It should almost never be necessary to scan IR, avoiding a big part of the
inefficiency in typical JTAG use.

\section{Main Loop}

A debugger continuously monitors \Rhaltsum to see if any harts have spontaneously
halted.

\section{Halting} \label{deb:halt}

To halt a hart, the debugger sets \Fhartsel and \Fhaltreq. Then it waits for
\Fallhalted to become 1.

\section{Accessing Registers}

\subsubsection{Using Abstract Command} \label{deb:abstractreg}

\noindent Read \Szero using abstract command:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rcommand & \Fsize$=2$, 0x1008 & Read \Szero \\
    \hline
    Read & \Rdatazero & - & Returns value that was in \Szero \\
    \hline
\end{tabulary}
\medskip

\noindent Write \Rmstatus using abstract command:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rdatazero & new value & \\
    \hline
    Write & \Rcommand & \Fsize$=2$, \Fwrite, 0x300 & Write \Rmstatus \\
    \hline
\end{tabulary}
\medskip

\subsubsection{Using Program Buffer} \label{deb:regprogbuf}

Abstract commands are used to exchange data with GPRs. Using this mechanism, other
registers can be accessed by moving their value into/out of GPRs.

\noindent Write \Rmstatus using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt csrw s0, MSTATUS} & \\
    \hline
    Write & \Rprogbufone & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & new value & \\
    \hline
    Write & \Rcommand & \Fsize$=2$, \Fpostexec, \Fwrite, 0x1008 &
        Write \Szero, then execute program buffer \\
    \hline
\end{tabulary}
\medskip

\noindent Read \Fone using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt fmv.x.s s0, f1} & \\
    \hline
    Write & \Rprogbufone & {\tt ebreak} & \\
    \hline
    Write & \Rcommand & \Fpreexec, 0x1008 & Execute program buffer, then read \Szero \\
    \hline
    Read & \Rdatazero & - & Returns the value that was in \Fone \\
    \hline
\end{tabulary}
\medskip

\section{Reading Memory}

\subsubsection{Using System Bus Access} \label{deb:mrsysbus}

\noindent Read a word from memory using system bus access:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rsbaddresszero & address & \\
    \hline
    Write & \Rsbcs & \Fsbaccess$=2$, \Fsbsingleread & Perform a read \\
    \hline
    Read & \Rsbdatazero & - & Value read from memory \\
    \hline
\end{tabulary}
\medskip

\noindent Read block of memory using system bus access:

\begin{tabulary}{\textwidth}{|r|r|L|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rsbaddresszero & address & \\
    \hline
    Write & \Rsbcs & \Fsbaccess$=2$, \Fsbsingleread, \Fsbautoread,
        \Fsbautoincrement & Turn on autoread and autoincrement, and perform a
        read \\
    \hline
    Read & \Rsbdatazero & - & Value read from memory \\
    \hline
    Read & \Rsbdatazero & - & Next value read from memory \\
    \hline
    ... & ... & ... & ... \\
    \hline
    Write & \Rsbcs & 0 & Clear \Fsbautoread \\
    \hline
    Read & \Rdatazero & - & Get last value read from memory. \\
    \hline
\end{tabulary}
\medskip

\subsubsection{Using Program Buffer} \label{deb:mrprogbuf}

\noindent Read a word from memory using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt lw s0, 0(s0)} & \\
    \hline
    Write & \Rprogbufone & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & address & \\
    \hline
    Write & \Rcommand & \Fwrite, \Fpostexec, 0x1008 & Write \Szero, then execute program buffer \\
    \hline
    Write & \Rcommand & 0x1008 & Read \Szero \\
    \hline
    Read & \Rdatazero & - & Value read from memory \\
    \hline
\end{tabulary}
\medskip

\noindent Read block of memory using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt lw s1, 0(s0)} & \\
    \hline
    Write & \Rprogbufone & {\tt addi s0, s0, 4} & \\
    \hline
    Write & \Rprogbuftwo & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & address & \\
    \hline
    Write & \Rcommand & \Fwrite, \Fpostexec, 0x1008 & Write \Szero, then execute program buffer \\
    \hline
    Write & \Rcommand & \Fpostexec, 0x1009 & Read \Sone, then execute program buffer \\
    \hline
    Write & \Rabstractcs & \Fautoexecdata[0] & Set \Fautoexecdata[0] \\
    \hline
    Read & \Rdatazero & - & Get value read from memory, then execute program buffer \\
    \hline
    Read & \Rdatazero & - & Get next value read from memory, then execute program buffer \\
    \hline
    ... & ... & ... & ... \\
    \hline
    Write & \Rabstractcs & 0 & Clear \Fautoexecdata[0] \\
    \hline
    Read & \Rdatazero & - & Get last value read from memory. \\
    \hline
\end{tabulary}
\medskip

TODO: Table~\ref{tab:memread} shows the scans involved in reading a single word using
this method.

\begin{table}[htp]
    \centering
    \caption{Memory Read Timeline}
    \label{tab:memread}
    \begin{tabulary}{\textwidth}{|r|l|L|}
        \hline
        & JTAG State & Activity \\
        \hline
        TODO & TODO & TODO \\
%        1 & Shift-DR & Debugger shifts in write of 0x41002403 to dram[0], and
%        gets back the result of whatever happened previously. \\
%        & Update-DR & DTM starts read from dram[0], followed by write to
%        dram[0]. \\
%        \hline
%        2 & Capture-DR & DTM captures results of read from dram[0]. \\
%        & Shift-DR & Debugger shifts in write of 0x42483 to dram[1], and gets
%        back the old contents of the first word in Debug RAM. \\
%        & Update-DR & DTM starts read from dram[1], followed by write to
%        dram[1]. \\
%        \hline
%        3 & Capture-DR & DTM captures results of read from dram[1]. \\
%        & Shift-DR & Debugger shifts in write of 0x40902823 to dram[2], and
%        gets back the old contents of the second word in Debug RAM. \\
%        & Update-DR & DTM starts read from dram[2], followed by write to
%        dram[2]. \\
%        \hline
%        4 & Capture-DR & DTM captures results of read from dram[2]. \\
%        & Shift-DR & Debugger shifts in write of 0x3f80006f to dram[3], and
%        gets back the old contents of the third word in Debug RAM. \\
%        & Update-DR & DTM starts read from dram[3], followed by write to
%        dram[3]. \\
%        \hline
%        5 & Capture-DR & DTM captures results of read from dram[3]. \\
%        & Shift-DR & Debugger shifts in write of the address the user wants to
%        read from to dram[4], using the interrupting Debug RAM register to assert
%        the Debug Interrupt. The old contents of the fourth word in Debug RAM
%        are shifted out. \\
%        & Update-DR & DTM starts read from dram[4], followed by write to
%        dram[4], and then sets the interrupt bit. The hart will respond to the
%        Debug Interrupt by executing the program in Debug RAM which in this
%        case will read the address written, and replace the entry in Debug RAM
%        with the data at that address. \\
%        \hline
%        6 & Capture-DR & DTM captures results of read from dram[4]. \\
%        & Shift-DR & Debugger shifts in read from dram[4], and gets back the
%        old contents of the fourth word in Debug RAM. (This is the value that
%        was there just before the address was written there.) \\
%        & Update-DR & DTM starts read from dram[4]. \\
%        \hline
%        7 & Capture-DR & DTM captures results of read from dram[4]. \\
%        & Shift-DR & Debugger shifts in nop, and gets back the contents of the
%        fourth word in Debug RAM. This is the value that was there during the
%        previous Update-DR, which is the result of the Debug Program execution.
%        \\
        \hline
    \end{tabulary}
\end{table}

\section{Writing Memory} \label{writemem}

TODO: Just like reading memory.

\subsubsection{Using System Bus Access} \label{deb:mrsysbus}

\noindent Write a word to memory using system bus access:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rsbaddresszero & address & \\
    \hline
    Write & \Rsbdatazero & value & \\
    \hline
\end{tabulary}
\medskip

\noindent Write block of memory using system bus access:

\begin{tabulary}{\textwidth}{|r|r|L|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rsbaddresszero & address & \\
    \hline
    Write & \Rsbcs & \Fsbaccess$=2$, \Fsbautoincrement & Turn on autoincrement \\
    \hline
    Write & \Rsbdatazero & value0 & \\
    \hline
    Write & \Rsbdatazero & value1 & \\
    \hline
    ... & ... & ... & ... \\
    \hline
    Write & \Rsbdatazero & valueN & \\
    \hline
\end{tabulary}
\medskip

\subsubsection{Using Program Buffer} \label{deb:mrprogbuf}

\noindent Write a word to memory using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt sw 0(s0), s1} & \\
    \hline
    Write & \Rprogbufone & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & value & \\
    \hline
    Write & \Rcommand & \Fwrite, 0x1008 & Write \Szero \\
    \hline
    Write & \Rdatazero & address & \\
    \hline
    Write & \Rcommand & \Fwrite, \Fpostexec, 0x1009 & Write \Sone, then execute program buffer \\
    \hline
\end{tabulary}
\medskip

\noindent Write block of memory using program buffer:

\begin{tabulary}{\textwidth}{|r|r|r|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt sw s1, 0(s0)} & \\
    \hline
    Write & \Rprogbufone & {\tt addi s0, s0, 4} & \\
    \hline
    Write & \Rprogbuftwo & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & address & \\
    \hline
    Write & \Rcommand & \Fwrite, 0x1008 & Write \Szero \\
    \hline
    Write & \Rdatazero & value0 & \\
    \hline
    Write & \Rcommand & \Fwrite, \Fpostexec, 0x1009 & Write \Sone, then execute program buffer \\
    \hline
    Write & \Rabstractcs & \Fautoexecdata[0] & Set \Fautoexecdata[0] \\
    \hline
    Write & \Rdatazero & value1 & \\
    \hline
    ... & ... & ... & ... \\
    \hline
    Write & \Rdatazero & valueN & \\
    \hline
    Write & \Rabstractcs & 0 & Clear \Fautoexecdata[0] \\
    \hline
\end{tabulary}
\medskip

\begin{commentary}
    % Select-DR-Scan to Shift-DR: 2
    % Shift-DR to Exit1-DR: dbus register is abits+33 bits, so 38
    % Exit1-DR to Select-DR-Scan: 2
    % Total: 42

    TODO: maybe update

    After the instruction buffer is configured, each word can be written to the
    target in 42 TCK cycles. That's 76\% efficient, and translates to a
    download speed of 930KB/s at a 10MHz TCK.  That should be good enough that
    it's not worth making the JTAG interface more complex to improve the
    efficiency. (This assumes the Debug Bus uses 5 address bits and that the
    debugger never has to wait for the core.)
\end{commentary}

\section{Running}

First, the debugger should restore any registers that it has clobbered.  Once
that's done, it can let the core run by setting \Fresumereq.

\section{Single Step}

A debugger can single step the core by setting a breakpoint on the next
instruction and letting the core run, or by asking the hardware to perform a
single step. The former requires the debugger to have much more knowledge of
the hardware than the latter, so the latter is preferred.

Using the hardware single step feature is almost the same as regular running.
The debugger just sets \Fstep in \Rdcsr before letting the core run. The core
behaves exactly as in the running case, except that interrupts are left off and
it only fetches and executes a single instruction before re-entering Debug
Mode.

\section{Handling Exceptions}

Generally the debugger can avoid exceptions by being careful with the programs
it writes. Sometimes they are unavoidable though, eg. if the user asks to
access memory or a CSR that is not implemented. A typical debugger will not
know enough about the platform to know what's going to happen, and must attempt
the access to determine the outcome.

When an exception occurs while executing the Program Buffer, \Fcmderr becomes
set. The debugger can check this field to see whether a program encountered an
exception.  If there was an exception, it's left to the debugger to know what
must have caused it.

\section{Quick Access} \label{quickaccess}

Halt the hart for a minimum amount of time to perform a single memory write.

There are 2 different instructions to transfer data between GPRs and the {\tt
data} registers. They are either loads/stores or CSR reads/writes. The specific
addresses also vary. This is all specified in \Rhartinfo. The example here uses
the pseudo-op {\tt transfer dest, src} to represent all these options.

\begin{tabulary}{\textwidth}{|r|r|l|L|}
    \hline
    Op & Address & Value & Comment \\
    \hline
    Write & \Rprogbufzero & {\tt transfer arg2, s0} & \\
    \hline
    Write & \Rprogbufone & {\tt transfer s0, arg0} & \\
    \hline
    Write & \Rprogbuftwo & {\tt transfer arg0, s1} & \\
    \hline
    Write & \Rprogbufthree & {\tt transfer s1, arg1} & \\
    \hline
    Write & \Rprogbuffour & {\tt sw 0(s0), s1} & \\
    \hline
    Write & \Rprogbuffive & {\tt transfer arg1, s1} & \\
    \hline
    Write & \Rprogbufsix & {\tt transfer arg2, s0} & \\
    \hline
    Write & \Rprogbufseven & {\tt ebreak} & \\
    \hline
    Write & \Rdatazero & address & \\
    \hline
    Write & \Rdataone & data & \\
    \hline
    Write & \Rcommand & 0x10000000 & Perform quick access \\
    \hline
\end{tabulary}
\medskip

\chapter{Trace Module}

{\bf This part of the spec needs work before it's ready to be implemented,
which is why it's in the appendix. It's left here to give a rough idea of some
of the issues to consider.}

Aside from viewing the current state of a core, knowing what happened in the
past can be incredibly helpful. Capturing an execution trace can give a user
that view.  Unfortunately processors run so fast that they generate trace data
at a very large rate. To help deal with this, the trace data format allows for
some simple compression.

The trace functionality described here aims to support 3 different use cases:
\begin{enumerate}
    \item Full reconstruction of all processor state, including register values
        etc. To achieve this goal the decoder will have to know what code is
        being executed, and know the exact behavior of every RISC-V
        instruction.
    \item Reconstruct just the instruction stream. Get enough data from the
        trace stream that it is possible to make a list of every instruction
        executed.  This is possible without knowing anything about the code or
        the core executing it.
    \item Watch memory accesses for a certain memory region.
\end{enumerate}

Trace data may be stored to a special on-core RAM, RAM on the system bus, or to
a dedicated off-chip interface. Only the system RAM destination is covered
here.

\section{Trace Data Format}

Trace data should be both compact and easy to generate. Ideally it's also easy
to decode, but since decoding doesn't have to happen in real time and will
usually have a powerful workstation to do the work, this is the least important
concern.

Trace data consists of a stream of 4-bit packets, which are stored in memory in
32-bit words by putting the first packet in bits 3:0 of the 32-bit word, the
second packet into bits 7:4, and so on. Trace packets and their encoding are
listed in Table~\ref{tab:tracepackets}.

\begin{table}[htp]
   \centering
   \caption{Trace Sequence Header Packets}
   \label{tab:tracepackets}
   \begin{tabulary}{\textwidth}{|l|l|L|}
      \hline
      0000 & Nop & Packet that indicates no data. The trace source must use
      these to ensure that there are 8 synchronization points in each buffer. \\
      \hline
      0001 & PC & Followed by a Value Sequence containing bits XLEN-1:1 of the
      PC if the compressed ISA is supported, or bits XLEN-1:2 of the PC if the
      compressed ISA is not supported.
      Missing bits must be filled in with the last PC value. \\
      \hline
      0010 & Branch Taken & \\
      \hline
      0011 & Branch Not Taken & \\
      \hline
      0100 & Trace Enabled & Followed by a single packet indicating the version
      of the trace data (currently 0). \\
      \hline
      0101 & Trace Disabled & Indicates that trace was purposefully disabled,
      or that some sequences were dropped because the trace buffer overflowed. \\
      \hline
      0110 & Privilege Level & Followed by a packet containing whether the
      cause of the change was an interrupt (1) or something else (0) in bit 3,
      PRV[1:0] in bits 2:1, and IE in bit 0. \\
      \hline
      0111 & Change Hart & Followed by a Value Sequence containing the hart ID
      of the hart whose trace data follows. Missing bits must be filled in with
      0. \\
      \hline
      1000 & Load Address & Followed by a Value Sequence containing the
      address.  Missing bits must be filled in with the last Load Address
      value. \\
      \hline
      1001 & Store Address & Followed by a Value Sequence containing the
      address. Missing bits must be filled in with the last Store Address
      value. \\
      \hline
      1010 & Load Data & Followed by a Value Sequence containing the data.
      Missing bits must be filled in by sign extending the value. \\
      \hline
      1011 & Store Data & Followed by a Value Sequence containing the data.
      Missing bits must be filled in by sign extending the value. \\
      \hline
      1100 & Timestamp & Followed by a Value Sequence containing the timestamp.
      Missing bits should be filled in with the last Timestamp value. \\
      \hline
      1101 & Reserved & Reserved for future standards. \\
      \hline
      1110 & Custom & Reserved for custom trace data. \\
      \hline
      1111 & Custom & Reserved for custom trace data. \\
      \hline
   \end{tabulary}
\end{table}

Several header packets are followed by a Value Sequence, which can encode
values between 4 and 64 bits. The sequence consists first of a 4-bit size
packet which contains a single number N.  It is followed by N+1 4-bit packets
which contain the value. The first packet contains bits 3:0 of the value. The
next packet contains bits 7:4, and so on.

\section{Trace Events}

Trace events are events that occur when a core is running that result in trace
packets being emitted. They are listed in Table~\ref{tab:traceevents}.

\begin{table}[htp]
   \centering
   \caption{Trace Data Events}
   \label{tab:traceevents}
   \begin{tabulary}{\textwidth}{|l|L|}
      \hline
      Opcode & Action \\
      \hline
      {\tt jal} & If \Femitbranch is disabled but \Femitpc is enabled, emit
      2 PC values: first the address of the instruction, then the address being
      jumped to. \\
      \hline
      {\tt jalr} & If \Femitbranch is disabled but \Femitpc is enabled, emit 2 PC
      values: first the address of the instruction, then the address being
      jumped to. Otherwise, if \Femitstoredata is enabled emit just the
      destination PC. \\
      \hline
      BRANCH & If \Femitbranch is enabled, emit either Branch Taken or Branch
      Not Taken.  Otherwise if \Femitpc is enabled and the branch is taken,
      emit 2 PC values: first the address of the branch, then the address being
      branched to. \\
      \hline
      LOAD & If \Femitloadaddr is enabled, emit the address.  If
      \Femitloaddata is enabled, emit the data that was loaded. \\
      \hline
      STORE & If \Femitstoreaddr is enabled, emit the address. If
      \Femitstoredata is enabled, emit the data that is stored. \\
      \hline
      Traps & {\tt scall}, {\tt sbreak}, {\tt ecall}, {\tt ebreak}, and {\tt
      eret} emit the same as if they were {\tt jal} instructions. In addition they
      also emit a Privilege Level sequence. \\
      \hline
      Interrupts & Emit PC (if enabled) of the last instruction executed.  Emit
      Privilege Level (if enabled).  Finally emit the new PC (if enabled). \\
      \hline
      CSR instructions & For reads emit Load Data (if enabled). For writes emit
      Store Data (if enabled). \\
      \hline
      Data Dropped & After packet sequences are dropped because data is
      generated too quickly, Trace Disabled must be emitted. It's not necessary
      to follow that up with a Trace Enabled sequence. \\
      \hline
   \end{tabulary}
\end{table}

\section{Synchronization}

If a trace buffer wraps, it is no longer clear what in the buffer is a header
and what isn't. To guarantee that a trace decoder can sync up easily, each
trace buffer must have 8 synchronization points, spaced evenly throughout the
buffer, with the first one at the very start of the buffer. A synchronization
point is simply an address where there is guaranteed to be a sequence header.
To make this happen, the trace source can insert a number of Nop headers into
the sequence just before writing to the synchronization point.

Aside from synchronizing a place in the data stream, it's also necessary to
send a full PC, Read Address, Write Address, and Timestamp in order for those
to be fully decoded. Ideally that happens the first time after every
synchronization point, but bandwidth might prevent that. A trace source should
attempt to send one full value for each of these (assuming they're enabled)
soon after each synchronization point.

\section{Trace Registers}

\input{trace_registers.tex}

\chapter{Future Ideas}
Some future version of this spec may implement some of the following features.

\begin{enumerate}
   \item The spec defines several additions to the Device Tree which enable a
      debugger to discover hart IDs and supported triggers for all the cores
      in the system.
   \item DTMs can function as general bus slaves, so they would look like
      regular RAM to bus masters.
   \item Harts can be divided into groups. All the harts in the same group can
      be halted/run/stepped simultaneously. When a hart hits a breakpoint, all
      the other harts in the same group also halt within a few clock cycles.
   \item DTMs are specified for protocols like USB, I2C, SPI, and SWD.
   \item Core registers can be read without halting the processor.
   \item The debugger can communicate with the power manager to power cores up
      or down, and to query their status.
   \item Serial ports can raise an interrupt when a send/receive queue becomes full/empty.
   \item The debug interrupt can be masked by running code. If the interrupt is
      asserted, then deasserted, and then asserted again the debug interrupt
      happens anyway. This mechanism can be used to eg. read/write memory with
      minimal interruption, making sure never to interrupt during a critical
      piece of code.
   \item The debugger can non-intrusively sample a recent PC value from any
      running hart.
\end{enumerate}

\chapter{Change Log}

\begin{versionhistory}
    \input{changelog.tex}
\end{versionhistory}

\end{document}
